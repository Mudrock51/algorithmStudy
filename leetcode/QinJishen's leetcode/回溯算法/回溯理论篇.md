# 回溯算法
>纯暴力搜索算法, 回溯是递归的副产品, 只要有递归就会有回溯.
 - 组合问题: N个数里面按一定规则找出k个数的集合
 - 排列问题: N个数按一定规则全排列，有几种排列方式
 - 切割问题: 一个字符串按一定规则有几种切割方式
 - 子集问题: 一个N个数的集合里有多少符合条件的子集.
 - 棋盘问题: N皇后, 解数独问题.

所有的回溯法都可以抽象成一个树形结构(n叉树), 这个树的**宽度**就是我们每个节点处理的**集合的大小**, 树的**深度**就是**递归深度**

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png)



>回溯法的模版
```cpp
vector<int> path; //* 收集路径
vector<vector<int>> result; //* 收集结果
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

>回溯三部曲
1. 递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑





### 组合问题

- 基本理念: **for循环横向遍历，递归纵向遍历，回溯不断调整结果集**
- 优化方法: **剪枝**
  - **for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了**。
- 组合问题中使用到 startIndex : 
  - 一个集合来求组合的话，就需要startIndex(求组合总和)
  - 多个集合取组合，各个集合之间相互不影响，那么就不用startIndex: (如电话号码的字母组合)

- 去重逻辑: **“树枝去重”和“树层去重”**
  - “使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。
  - **used[i - 1] == true，说明同一树枝candidates[i - 1]使用过**
  - **used[i - 1] == false，说明同一树层candidates[i - 1]使用过**



### 切割问题

切割问题的几个难点:

- 切割问题其实类似组合问题

- 如何模拟那些切割线

- 切割问题中递归如何终止

- 在递归循环中如何截取子串

- 如何判断回文

- **切割过的地方不能重复切割所以递归函数需要传入i + 1.**

  



### 子集问题

- 基本逻辑: **在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果**。

- 终止条件: 如果要写终止条件，注意：`result.push_back(path);`要放在终止条件的上面，如下：

```cpp
result.push_back(path); 		// 收集子集，要放在终止添加的上面，否则会漏掉结果
if (startIndex >= nums.size()) {        // 终止条件可以不加
    return;
}
```

- 去重逻辑: **“树枝去重”和“树层去重”**
  - “使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。
  - **used[i - 1] == true，说明同一树枝candidates[i - 1]使用过**
  - **used[i - 1] == false，说明同一树层candidates[i - 1]使用过**
  - **使用set 针对同一父节点的本层去重, 但子集问题一定要排序(避免重复)**





### 排列问题

- 基本逻辑: 排列是有序的, 处理排列问题就不用使用 startIndex.
  - 每层都是从0开始搜索而不是startIndex
  - 需要used数组记录path里都放了哪些元素了

- 去重逻辑: **“树枝去重”和“树层去重”**

  - “使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。

  - **used[i - 1] == true，说明同一树枝candidates[i - 1]使用过**

  - **used[i - 1] == false，说明同一树层candidates[i - 1]使用过**

    **使用(used[i - 1] == false)，即树层去重，效率更高**



## 性能分析

以下在计算空间复杂度的时候我都把系统栈（不是数据结构里的栈）所占空间算进去。

**子集问题分析：**

- 时间复杂度：O(2^n^)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n^)
- 空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)

**排列问题分析：**

- 时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
- 空间复杂度：O(n)，和子集问题同理。

**组合问题分析：**

- 时间复杂度：O(2^n^)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：O(n)，和子集问题同理。

**N皇后问题分析：**

- 时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * .... * 1。
- 空间复杂度：O(n)，和子集问题同理。

**解数独问题分析：**

- 时间复杂度：O(9^m^) , m是'.'的数目。
- 空间复杂度：O(n^2^)，递归的深度是n^2^

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！**

### 
